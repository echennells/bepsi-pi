name: Benchmark Spark Payment Speed

on:
  workflow_dispatch:
    inputs:
      num_payments:
        description: 'Number of payments to send (sats and tokens each)'
        required: false
        default: '10'
  push:
    branches:
      - main
      - spark-support

jobs:
  benchmark:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: asdfasdf

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Sweep funds to test wallet before benchmark
        env:
          TEST_WALLET_ADDRESS: 'sp1pgss8zk663885kz8ftfexlayqgyfzpj3kjued5vwkz8y9z7646779qy3rk5rpd'
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
          SPARK_PIN_517_MNEMONIC: ${{ secrets.SPARK_PIN_517_MNEMONIC }}
          SPARK_PIN_518_MNEMONIC: ${{ secrets.SPARK_PIN_518_MNEMONIC }}
          SPARK_PIN_524_MNEMONIC: ${{ secrets.SPARK_PIN_524_MNEMONIC }}
          SPARK_PIN_525_MNEMONIC: ${{ secrets.SPARK_PIN_525_MNEMONIC }}
          SPARK_PIN_528_MNEMONIC: ${{ secrets.SPARK_PIN_528_MNEMONIC }}
        run: |
          node -e "
          const { IssuerSparkWallet } = require('@buildonspark/issuer-sdk');
          (async () => {
            console.log('üßπ Sweeping any stuck funds back to test wallet...');
            const testWalletAddress = process.env.TEST_WALLET_ADDRESS;
            const pins = [516, 517, 518, 524, 525, 528];
            let totalSwept = 0;

            for (const pin of pins) {
              const mnemonic = process.env[\`SPARK_PIN_\${pin}_MNEMONIC\`];
              if (!mnemonic) continue;

              try {
                const { wallet } = await IssuerSparkWallet.initialize({
                  mnemonicOrSeed: mnemonic,
                  options: { network: 'MAINNET' }
                });

                const balance = await wallet.getBalance();
                const sats = Number(balance.balance);

                if (sats > 0) {
                  await wallet.transfer({
                    receiverSparkAddress: testWalletAddress,
                    amountSats: sats
                  });
                  console.log(\`  ‚úÖ Swept \${sats} sats from pin \${pin}\`);
                  totalSwept += sats;
                }
              } catch (error) {
                console.log(\`  ‚ö†Ô∏è Pin \${pin}: \${error.message}\`);
              }
            }

            if (totalSwept > 0) {
              console.log(\`üí∞ Total swept: \${totalSwept} sats\`);
              console.log('‚è≥ Waiting 20 seconds for funds to settle...');
              await new Promise(resolve => setTimeout(resolve, 20000));
              console.log('‚úì Ready to proceed with benchmark');
            } else {
              console.log('‚úì No funds to sweep');
            }
          })();
          "

      - name: Run payment speed benchmark
        env:
          NUM_PAYMENTS: ${{ github.event.inputs.num_payments || '10' }}
          TEST_WALLET_MNEMONIC: ${{ secrets.TEST_WALLET_MNEMONIC }}
          SPARK_PIN_516_ADDRESS: ${{ secrets.SPARK_PIN_516_ADDRESS }}
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
          SPARK_BEPSITOKEN_IDENTIFIER: 'btkn1xecvlqngfwwvw2z38s67rn23r76m2vpkmwavfr9cr6ytzgqufu0ql0a4qk'
        run: |
          cat > benchmark-payments.js << 'EOFSCRIPT'
          #!/usr/bin/env node

          async function benchmarkPayments() {
            try {
              const { IssuerSparkWallet } = await import("@buildonspark/issuer-sdk");

              const numPayments = parseInt(process.env.NUM_PAYMENTS || '10');
              const testWalletMnemonic = process.env.TEST_WALLET_MNEMONIC;
              const pinAddress = process.env.SPARK_PIN_516_ADDRESS;
              const pinMnemonic = process.env.SPARK_PIN_516_MNEMONIC;
              const tokenId = process.env.SPARK_BEPSITOKEN_IDENTIFIER;

              console.log(`üî¨ Benchmarking Spark Payment Detection Speed`);
              console.log(`üìä Testing ${numPayments} sats payments + ${numPayments} token payments\n`);

              // Initialize wallets
              const { wallet: testWallet } = await IssuerSparkWallet.initialize({
                mnemonicOrSeed: testWalletMnemonic,
                options: { network: "MAINNET" }
              });

              const { wallet: pinWallet } = await IssuerSparkWallet.initialize({
                mnemonicOrSeed: pinMnemonic,
                options: { network: "MAINNET" }
              });

              console.log(`üí∞ Test wallet balance: ${await testWallet.getBalance().then(b => b.balance)} sats\n`);

              // Track detection times
              const detectionTimes = [];
              let detectedCount = 0;

              // Setup event listener for sats payments
              pinWallet.on('transfer:claimed', async (transferId) => {
                const detectionTime = Date.now();
                detectedCount++;
                console.log(`‚úÖ Payment ${detectedCount} detected! Transfer ID: ${transferId}`);

                // Find matching sent payment
                const match = detectionTimes.find(p => !p.detectedAt && p.type === 'sats');
                if (match) {
                  match.detectedAt = detectionTime;
                  match.latency = detectionTime - match.sentAt;
                  console.log(`   ‚è±Ô∏è  Detection latency: ${match.latency}ms\n`);
                }
              });

              await new Promise(resolve => setTimeout(resolve, 2000));

              // Benchmark SATS payments
              console.log(`üí∏ Sending ${numPayments} sats payments...\n`);

              for (let i = 0; i < numPayments; i++) {
                const sentAt = Date.now();
                try {
                  const result = await testWallet.transfer({
                    receiverSparkAddress: pinAddress,
                    amountSats: 1000
                  });

                  detectionTimes.push({
                    type: 'sats',
                    paymentNum: i + 1,
                    txId: result.id,
                    sentAt,
                    detectedAt: null,
                    latency: null
                  });

                  console.log(`üì§ Sats payment ${i + 1}/${numPayments} sent - TX: ${result.id}`);

                  // Delay between payments to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 3000));
                } catch (error) {
                  console.error(`‚ùå Sats payment ${i + 1} failed:`, error.message);
                }
              }

              // Wait for all sats payments to be detected
              console.log(`\n‚è≥ Waiting for sats payment detection (30 seconds)...\n`);
              await new Promise(resolve => setTimeout(resolve, 30000));

              // Benchmark TOKEN payments
              console.log(`\nü™ô Sending ${numPayments} token payments...\n`);

              // Reinitialize wallet to refresh state after sats payments
              console.log('üîÑ Reinitializing test wallet to refresh state...');
              const { wallet: refreshedTestWallet } = await IssuerSparkWallet.initialize({
                mnemonicOrSeed: testWalletMnemonic,
                options: { network: "MAINNET" }
              });

              // Wait for state to sync
              await new Promise(resolve => setTimeout(resolve, 5000));

              // Refresh balance to get current token state
              const currentBalance = await refreshedTestWallet.getBalance();
              console.log(`   Current balance: ${currentBalance.balance} sats`);
              console.log(`   Token balances map size: ${currentBalance.tokenBalances ? currentBalance.tokenBalances.size : 'null'}`);

              if (currentBalance.tokenBalances && currentBalance.tokenBalances.size > 0) {
                console.log(`   Found ${currentBalance.tokenBalances.size} token types:`);
                for (const [tId, tData] of currentBalance.tokenBalances) {
                  const tAmount = Number(tData.balance) / Math.pow(10, 6);
                  console.log(`     Token: ${tAmount} (${tId.slice(0,20)}...)`);
                }
              } else {
                console.log(`   ‚ö†Ô∏è No tokens found in wallet after sats payments!`);
              }

              for (let i = 0; i < numPayments; i++) {
                const sentAt = Date.now();
                try {
                  const rawAmount = BigInt(1 * Math.pow(10, 6)); // 1 token
                  const result = await refreshedTestWallet.transferTokens({
                    tokenIdentifier: tokenId,
                    tokenAmount: rawAmount,
                    receiverSparkAddress: pinAddress
                  });

                  detectionTimes.push({
                    type: 'tokens',
                    paymentNum: i + 1,
                    txId: result,
                    sentAt,
                    detectedAt: null,
                    latency: null
                  });

                  console.log(`üì§ Token payment ${i + 1}/${numPayments} sent - TX: ${result}`);

                  // Delay between payments to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 3000));
                } catch (error) {
                  console.error(`‚ùå Token payment ${i + 1} failed:`, error.message);
                }
              }

              // Wait for token detection (polling happens every 5s)
              console.log(`\n‚è≥ Waiting for token payment detection (30 seconds, polling every 5s)...\n`);
              await new Promise(resolve => setTimeout(resolve, 30000));

              // Calculate statistics
              console.log(`\n${"=".repeat(70)}`);
              console.log(`üìä BENCHMARK RESULTS`);
              console.log(`${"=".repeat(70)}\n`);

              const satsPayments = detectionTimes.filter(p => p.type === 'sats' && p.latency !== null);
              const tokenPayments = detectionTimes.filter(p => p.type === 'tokens' && p.latency !== null);

              if (satsPayments.length > 0) {
                const satsLatencies = satsPayments.map(p => p.latency);
                const satsAvg = satsLatencies.reduce((a, b) => a + b, 0) / satsLatencies.length;
                const satsMin = Math.min(...satsLatencies);
                const satsMax = Math.max(...satsLatencies);

                console.log(`‚ö° SATS PAYMENTS (EventEmitter - Real-time):`);
                console.log(`   Detected: ${satsPayments.length}/${numPayments}`);
                console.log(`   Average latency: ${satsAvg.toFixed(0)}ms`);
                console.log(`   Min latency: ${satsMin}ms`);
                console.log(`   Max latency: ${satsMax}ms\n`);
              }

              if (tokenPayments.length > 0) {
                const tokenLatencies = tokenPayments.map(p => p.latency);
                const tokenAvg = tokenLatencies.reduce((a, b) => a + b, 0) / tokenLatencies.length;
                const tokenMin = Math.min(...tokenLatencies);
                const tokenMax = Math.max(...tokenLatencies);

                console.log(`ü™ô TOKEN PAYMENTS (Polling - 5s intervals):`);
                console.log(`   Detected: ${tokenPayments.length}/${numPayments}`);
                console.log(`   Average latency: ${tokenAvg.toFixed(0)}ms`);
                console.log(`   Min latency: ${tokenMin}ms`);
                console.log(`   Max latency: ${tokenMax}ms\n`);
              }

              console.log(`${"=".repeat(70)}\n`);

              // Detailed results
              console.log(`üìã Detailed Results:\n`);
              for (const payment of detectionTimes) {
                if (payment.latency) {
                  console.log(`${payment.type === 'sats' ? '‚ö°' : 'ü™ô'} ${payment.type.toUpperCase()} #${payment.paymentNum}: ${payment.latency}ms`);
                } else {
                  console.log(`‚ùå ${payment.type.toUpperCase()} #${payment.paymentNum}: NOT DETECTED`);
                }
              }

              console.log(`\n‚úÖ Benchmark complete!`);

            } catch (error) {
              console.error("‚ùå Benchmark failed:", error.message);
              process.exit(1);
            }
          }

          benchmarkPayments();
          EOFSCRIPT

          node benchmark-payments.js