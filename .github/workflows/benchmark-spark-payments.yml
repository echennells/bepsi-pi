name: Benchmark Spark Payment Speed

on:
  workflow_dispatch:
    inputs:
      num_payments:
        description: 'Number of payments to send (sats and tokens each)'
        required: false
        default: '10'
      benchmark_type:
        description: 'Which benchmark to run'
        required: false
        default: 'comparison'
        type: choice
        options:
        - comparison
        - production-hybrid
        - experimental
        - original
        - sats-race
  push:
    branches:
      - main
      - spark-support

jobs:
  benchmark:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: asdfasdf

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Sweep funds to test wallet before benchmark
        env:
          TEST_WALLET_ADDRESS: 'sp1pgss8zk663885kz8ftfexlayqgyfzpj3kjued5vwkz8y9z7646779qy3rk5rpd'
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
          SPARK_PIN_517_MNEMONIC: ${{ secrets.SPARK_PIN_517_MNEMONIC }}
          SPARK_PIN_518_MNEMONIC: ${{ secrets.SPARK_PIN_518_MNEMONIC }}
          SPARK_PIN_524_MNEMONIC: ${{ secrets.SPARK_PIN_524_MNEMONIC }}
          SPARK_PIN_525_MNEMONIC: ${{ secrets.SPARK_PIN_525_MNEMONIC }}
          SPARK_PIN_528_MNEMONIC: ${{ secrets.SPARK_PIN_528_MNEMONIC }}
        run: |
          node -e "
          const { IssuerSparkWallet } = require('@buildonspark/issuer-sdk');
          (async () => {
            console.log('🧹 Sweeping any stuck funds back to test wallet...');
            const testWalletAddress = process.env.TEST_WALLET_ADDRESS;
            const pins = [516, 517, 518, 524, 525, 528];
            let totalSwept = 0;

            for (const pin of pins) {
              const mnemonic = process.env[\`SPARK_PIN_\${pin}_MNEMONIC\`];
              if (!mnemonic) continue;

              try {
                const { wallet } = await IssuerSparkWallet.initialize({
                  mnemonicOrSeed: mnemonic,
                  options: { network: 'MAINNET' }
                });

                const balance = await wallet.getBalance();
                const sats = Number(balance.balance);

                if (sats > 0) {
                  await wallet.transfer({
                    receiverSparkAddress: testWalletAddress,
                    amountSats: sats
                  });
                  console.log(\`  ✅ Swept \${sats} sats from pin \${pin}\`);
                  totalSwept += sats;
                }
              } catch (error) {
                console.log(\`  ⚠️ Pin \${pin}: \${error.message}\`);
              }
            }

            if (totalSwept > 0) {
              console.log(\`💰 Total swept: \${totalSwept} sats\`);
              console.log('⏳ Waiting 20 seconds for funds to settle...');
              await new Promise(resolve => setTimeout(resolve, 20000));
              console.log('✓ Ready to proceed with benchmark');
            } else {
              console.log('✓ No funds to sweep');
            }
          })();
          "

      - name: Run comparison benchmarks
        if: ${{ github.event.inputs.benchmark_type == 'comparison' || github.event.inputs.benchmark_type == '' }}
        env:
          NUM_PAYMENTS: ${{ github.event.inputs.num_payments || '5' }}
          TEST_WALLET_ADDRESS: 'sp1pgss8zk663885kz8ftfexlayqgyfzpj3kjued5vwkz8y9z7646779qy3rk5rpd'
          TEST_WALLET_MNEMONIC: ${{ secrets.TEST_WALLET_MNEMONIC }}
          SPARK_PIN_516_ADDRESS: ${{ secrets.SPARK_PIN_516_ADDRESS }}
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
          SPARK_BEPSITOKEN_IDENTIFIER: 'btkn1xecvlqngfwwvw2z38s67rn23r76m2vpkmwavfr9cr6ytzgqufu0ql0a4qk'
        run: |
          echo "🚀 Running comparison benchmarks..."
          node run-comparison-benchmarks.js

      - name: Run production hybrid benchmark
        if: ${{ github.event.inputs.benchmark_type == 'production-hybrid' }}
        env:
          NUM_PAYMENTS: ${{ github.event.inputs.num_payments || '10' }}
          TEST_WALLET_MNEMONIC: ${{ secrets.TEST_WALLET_MNEMONIC }}
          SPARK_PIN_516_ADDRESS: ${{ secrets.SPARK_PIN_516_ADDRESS }}
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
          SPARK_BEPSITOKEN_IDENTIFIER: 'btkn1xecvlqngfwwvw2z38s67rn23r76m2vpkmwavfr9cr6ytzgqufu0ql0a4qk'
        run: |
          echo "🏭 Running production hybrid benchmark..."
          node benchmark-production-hybrid.js

      - name: Run experimental benchmark
        if: ${{ github.event.inputs.benchmark_type == 'experimental' }}
        env:
          NUM_PAYMENTS: ${{ github.event.inputs.num_payments || '10' }}
          TEST_WALLET_MNEMONIC: ${{ secrets.TEST_WALLET_MNEMONIC }}
          SPARK_PIN_516_ADDRESS: ${{ secrets.SPARK_PIN_516_ADDRESS }}
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
          SPARK_BEPSITOKEN_IDENTIFIER: 'btkn1xecvlqngfwwvw2z38s67rn23r76m2vpkmwavfr9cr6ytzgqufu0ql0a4qk'
        run: |
          echo "🧪 Running experimental benchmark..."
          node benchmark-experimental.js

      - name: Run sats race benchmark (Events vs Polling)
        if: ${{ github.event.inputs.benchmark_type == 'sats-race' }}
        env:
          NUM_PAYMENTS: ${{ github.event.inputs.num_payments || '3' }}
          TEST_WALLET_ADDRESS: 'sp1pgss8zk663885kz8ftfexlayqgyfzpj3kjued5vwkz8y9z7646779qy3rk5rpd'
          TEST_WALLET_MNEMONIC: ${{ secrets.TEST_WALLET_MNEMONIC }}
          SPARK_PIN_516_ADDRESS: ${{ secrets.SPARK_PIN_516_ADDRESS }}
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
        run: |
          echo "🏁 Running sats race benchmark (Events vs Polling)..."
          node benchmark-sats-race.js

      - name: Run original benchmark (for reference)
        if: ${{ github.event.inputs.benchmark_type == 'original' }}
        env:
          NUM_PAYMENTS: ${{ github.event.inputs.num_payments || '10' }}
          TEST_WALLET_MNEMONIC: ${{ secrets.TEST_WALLET_MNEMONIC }}
          SPARK_PIN_516_ADDRESS: ${{ secrets.SPARK_PIN_516_ADDRESS }}
          SPARK_PIN_516_MNEMONIC: ${{ secrets.SPARK_PIN_516_MNEMONIC }}
          SPARK_BEPSITOKEN_IDENTIFIER: 'btkn1xecvlqngfwwvw2z38s67rn23r76m2vpkmwavfr9cr6ytzgqufu0ql0a4qk'
        run: |
          cat > benchmark-payments.js << 'EOFSCRIPT'
          #!/usr/bin/env node

          async function benchmarkPayments() {
            try {
              const { IssuerSparkWallet } = await import("@buildonspark/issuer-sdk");

              const numPayments = parseInt(process.env.NUM_PAYMENTS || '10');
              const testWalletMnemonic = process.env.TEST_WALLET_MNEMONIC;
              const pinAddress = process.env.SPARK_PIN_516_ADDRESS;
              const pinMnemonic = process.env.SPARK_PIN_516_MNEMONIC;
              const tokenId = process.env.SPARK_BEPSITOKEN_IDENTIFIER;

              console.log(`🔬 Benchmarking Spark Payment Detection Speed`);
              console.log(`📊 Testing ${numPayments} sats payments + ${numPayments} token payments\n`);

              // Initialize wallets
              const { wallet: testWallet } = await IssuerSparkWallet.initialize({
                mnemonicOrSeed: testWalletMnemonic,
                options: { network: "MAINNET" }
              });

              const { wallet: pinWallet } = await IssuerSparkWallet.initialize({
                mnemonicOrSeed: pinMnemonic,
                options: { network: "MAINNET" }
              });

              console.log(`💰 Test wallet balance: ${await testWallet.getBalance().then(b => b.balance)} sats\n`);

              // Track detection times
              const detectionTimes = [];
              let detectedCount = 0;

              // Track token balances for polling detection
              let previousTokenBalance = 0;
              let tokenDetectionInterval;

              // METHOD 1: Event-driven sats detection (REAL-TIME NOTIFICATIONS)
              pinWallet.on('transfer:claimed', async (transferId) => {
                const detectionTime = Date.now();
                console.log(`✅ Sats Payment detected via EVENT! Transfer ID: ${transferId}`);

                // Find matching sent payment
                const undetectedPayments = detectionTimes.filter(p => !p.detectedAt && p.type === 'sats');
                if (undetectedPayments.length > 0) {
                  const payment = undetectedPayments[0]; // Take the oldest undetected payment
                  payment.detectedAt = detectionTime;
                  payment.latency = detectionTime - payment.sentAt;
                  console.log(`   ⏱️  Sats EVENT Detection latency for payment #${payment.paymentNum}: ${payment.latency}ms\n`);
                }
              });

              // METHOD 2: Polling-based sats detection (5-second intervals) - BACKUP/COMPARISON
              let previousSatsBalance = 0;
              const checkSatsPayments = async () => {
                try {
                  const balance = await pinWallet.getBalance();
                  const currentSatsBalance = Number(balance.balance);

                  if (currentSatsBalance > previousSatsBalance) {
                    const detectionTime = Date.now();
                    const paymentAmount = currentSatsBalance - previousSatsBalance;
                    console.log(`⚠️ Sats Payment detected via POLLING FALLBACK! Amount: ${paymentAmount} sats (event missed this)`);

                    // Find all undetected sats payments and mark them as detected
                    const undetectedPayments = detectionTimes.filter(p => !p.detectedAt && p.type === 'sats');
                    const satsPerPayment = 1000; // We know each payment is 1000 sats
                    const paymentsToMark = Math.min(Math.floor(paymentAmount / satsPerPayment), undetectedPayments.length);

                    for (let i = 0; i < paymentsToMark; i++) {
                      const payment = undetectedPayments[i];
                      payment.detectedAt = detectionTime;
                      payment.latency = detectionTime - payment.sentAt;
                      payment.detectionMethod = 'polling'; // Mark as polling fallback
                      console.log(`   ⏱️  Sats POLLING FALLBACK Detection latency for payment #${payment.paymentNum}: ${payment.latency}ms`);
                    }

                    previousSatsBalance = currentSatsBalance;
                  }
                } catch (error) {
                  console.error(`Sats polling detection error: ${error.message}`);
                }
              };

              // Test: Try event-driven token detection (like sats) instead of polling
              pinWallet.on('balance:updated', async (balanceInfo) => {
                try {
                  const detectionTime = Date.now();
                  console.log(`🔔 Balance update event received:`, balanceInfo);

                  // Check if this is a token balance increase
                  const currentBalance = await pinWallet.getBalance();
                  let currentTokenBalance = 0;

                  if (currentBalance.tokenBalances && currentBalance.tokenBalances.has(tokenId)) {
                    const tokenData = currentBalance.tokenBalances.get(tokenId);
                    if (tokenData && tokenData.balance) {
                      currentTokenBalance = Number(tokenData.balance) / Math.pow(10, 6);
                    }
                  }

                  if (currentTokenBalance > previousTokenBalance) {
                    const paymentAmount = currentTokenBalance - previousTokenBalance;
                    console.log(`✅ Token Payment detected via EVENT! Amount: ${paymentAmount} tokens, New balance: ${currentTokenBalance}`);

                    // Find all undetected token payments and mark them as detected
                    const undetectedPayments = detectionTimes.filter(p => !p.detectedAt && p.type === 'tokens');
                    const paymentsToMark = Math.min(paymentAmount, undetectedPayments.length);

                    for (let i = 0; i < paymentsToMark; i++) {
                      const payment = undetectedPayments[i];
                      payment.detectedAt = detectionTime;
                      payment.latency = detectionTime - payment.sentAt;
                      console.log(`   ⏱️  Token EVENT Detection latency for payment #${payment.paymentNum}: ${payment.latency}ms`);
                    }

                    previousTokenBalance = currentTokenBalance;
                  }
                } catch (error) {
                  console.error(`Token event detection error: ${error.message}`);
                }
              });

              // Fallback: Keep polling as backup in case events don't work
              const checkTokenPayments = async () => {
                try {
                  const balance = await pinWallet.getBalance();
                  let currentTokenBalance = 0;

                  if (balance.tokenBalances && balance.tokenBalances.has(tokenId)) {
                    const tokenData = balance.tokenBalances.get(tokenId);
                    if (tokenData && tokenData.balance) {
                      currentTokenBalance = Number(tokenData.balance) / Math.pow(10, 6);
                    }
                  }

                  // Only detect if events haven't already caught it
                  if (currentTokenBalance > previousTokenBalance) {
                    const detectionTime = Date.now();
                    const paymentAmount = currentTokenBalance - previousTokenBalance;
                    console.log(`✅ Token Payment detected via POLLING (fallback)! Amount: ${paymentAmount} tokens`);

                    const undetectedPayments = detectionTimes.filter(p => !p.detectedAt && p.type === 'tokens');
                    const paymentsToMark = Math.min(paymentAmount, undetectedPayments.length);

                    for (let i = 0; i < paymentsToMark; i++) {
                      const payment = undetectedPayments[i];
                      payment.detectedAt = detectionTime;
                      payment.latency = detectionTime - payment.sentAt;
                      console.log(`   ⏱️  Token POLLING Detection latency for payment #${payment.paymentNum}: ${payment.latency}ms`);
                    }

                    previousTokenBalance = currentTokenBalance;
                  }
                } catch (error) {
                  console.error(`Token polling detection error: ${error.message}`);
                }
              };

              // Initialize baselines for both sats and tokens
              const initialBalance = await pinWallet.getBalance();

              // Initialize sats baseline
              previousSatsBalance = Number(initialBalance.balance);
              console.log(`📊 Initial pin wallet sats balance: ${previousSatsBalance} sats`);

              // Initialize token baseline
              if (initialBalance.tokenBalances && initialBalance.tokenBalances.has(tokenId)) {
                const tokenData = initialBalance.tokenBalances.get(tokenId);
                if (tokenData && tokenData.balance) {
                  previousTokenBalance = Number(tokenData.balance) / Math.pow(10, 6);
                }
              }
              console.log(`📊 Initial pin wallet token balance: ${previousTokenBalance} tokens`);

              // Start polling every 5 seconds for BOTH sats and tokens
              const pollingInterval = setInterval(() => {
                checkSatsPayments();
                checkTokenPayments();
              }, 5000);
              tokenDetectionInterval = pollingInterval; // Use same variable name for cleanup

              await new Promise(resolve => setTimeout(resolve, 2000));

              // Benchmark SATS payments
              console.log(`💸 Sending ${numPayments} sats payments...\n`);

              for (let i = 0; i < numPayments; i++) {
                const sentAt = Date.now();
                try {
                  const result = await testWallet.transfer({
                    receiverSparkAddress: pinAddress,
                    amountSats: 1000
                  });

                  detectionTimes.push({
                    type: 'sats',
                    paymentNum: i + 1,
                    txId: result.id,
                    sentAt,
                    detectedAt: null,
                    latency: null
                  });

                  console.log(`📤 Sats payment ${i + 1}/${numPayments} sent - TX: ${result.id}`);

                  // Longer delay between sats payments to prevent SDK database constraint violations
                  await new Promise(resolve => setTimeout(resolve, 15000));
                } catch (error) {
                  console.error(`❌ Sats payment ${i + 1} failed:`, error.message);
                }
              }

              // Wait for all sats payments to be detected
              console.log(`\n⏳ Waiting for sats payment detection (30 seconds)...\n`);
              await new Promise(resolve => setTimeout(resolve, 30000));

              // Benchmark TOKEN payments
              console.log(`\n🪙 Sending ${numPayments} token payments...\n`);

              // Reinitialize wallet to refresh state after sats payments
              console.log('🔄 Reinitializing test wallet to refresh state...');
              const { wallet: refreshedTestWallet } = await IssuerSparkWallet.initialize({
                mnemonicOrSeed: testWalletMnemonic,
                options: { network: "MAINNET" }
              });

              // Wait longer for state to sync in GitHub Actions environment
              await new Promise(resolve => setTimeout(resolve, 15000));

              // Refresh balance to get current token state
              const currentBalance = await refreshedTestWallet.getBalance();
              console.log(`   Current balance: ${currentBalance.balance} sats`);
              console.log(`   Token balances map size: ${currentBalance.tokenBalances ? currentBalance.tokenBalances.size : 'null'}`);

              if (currentBalance.tokenBalances && currentBalance.tokenBalances.size > 0) {
                console.log(`   Found ${currentBalance.tokenBalances.size} token types:`);
                for (const [tId, tData] of currentBalance.tokenBalances) {
                  const tAmount = Number(tData.balance) / Math.pow(10, 6);
                  console.log(`     Token: ${tAmount} (${tId.slice(0,20)}...)`);
                }
              } else {
                console.log(`   ⚠️ No tokens found in wallet after sats payments!`);
              }

              for (let i = 0; i < numPayments; i++) {
                const sentAt = Date.now();
                try {
                  const rawAmount = BigInt(1 * Math.pow(10, 6)); // 1 token
                  const result = await refreshedTestWallet.transferTokens({
                    tokenIdentifier: tokenId,
                    tokenAmount: rawAmount,
                    receiverSparkAddress: pinAddress
                  });

                  detectionTimes.push({
                    type: 'tokens',
                    paymentNum: i + 1,
                    txId: result,
                    sentAt,
                    detectedAt: null,
                    latency: null
                  });

                  console.log(`📤 Token payment ${i + 1}/${numPayments} sent - TX: ${result}`);

                  // Delay between payments to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 3000));
                } catch (error) {
                  console.error(`❌ Token payment ${i + 1} failed:`, error.message);
                }
              }

              // Wait for token detection (polling happens every 5s)
              console.log(`\n⏳ Waiting for token payment detection (30 seconds, polling every 5s)...\n`);
              await new Promise(resolve => setTimeout(resolve, 30000));

              // Stop token polling
              if (tokenDetectionInterval) {
                clearInterval(tokenDetectionInterval);
                console.log(`🛑 Stopped token detection polling`);
              }

              // Calculate statistics
              console.log(`\n${"=".repeat(70)}`);
              console.log(`📊 BENCHMARK RESULTS`);
              console.log(`${"=".repeat(70)}\n`);

              const satsPayments = detectionTimes.filter(p => p.type === 'sats' && p.latency !== null);
              const tokenPayments = detectionTimes.filter(p => p.type === 'tokens' && p.latency !== null);

              if (satsPayments.length > 0) {
                const satsLatencies = satsPayments.map(p => p.latency);
                const satsAvg = satsLatencies.reduce((a, b) => a + b, 0) / satsLatencies.length;
                const satsMin = Math.min(...satsLatencies);
                const satsMax = Math.max(...satsLatencies);

                // Separate by detection method
                const eventPayments = satsPayments.filter(p => !p.detectionMethod || p.detectionMethod !== 'polling');
                const pollingPayments = satsPayments.filter(p => p.detectionMethod === 'polling');

                console.log(`⚡ SATS PAYMENTS COMPARISON:`);
                console.log(`   Total Detected: ${satsPayments.length}/${numPayments}`);
                console.log(`   📡 Event Detection: ${eventPayments.length} payments`);
                console.log(`   📊 Polling Fallback: ${pollingPayments.length} payments`);

                if (eventPayments.length > 0) {
                  const eventLatencies = eventPayments.map(p => p.latency);
                  const eventAvg = eventLatencies.reduce((a, b) => a + b, 0) / eventLatencies.length;
                  console.log(`   📡 Event Avg Latency: ${eventAvg.toFixed(0)}ms`);
                }

                if (pollingPayments.length > 0) {
                  const pollingLatencies = pollingPayments.map(p => p.latency);
                  const pollingAvg = pollingLatencies.reduce((a, b) => a + b, 0) / pollingLatencies.length;
                  console.log(`   📊 Polling Avg Latency: ${pollingAvg.toFixed(0)}ms`);
                }

                console.log(`   Overall Average: ${satsAvg.toFixed(0)}ms`);
                console.log(`   Min: ${satsMin}ms, Max: ${satsMax}ms\n`);
              }

              if (tokenPayments.length > 0) {
                const tokenLatencies = tokenPayments.map(p => p.latency);
                const tokenAvg = tokenLatencies.reduce((a, b) => a + b, 0) / tokenLatencies.length;
                const tokenMin = Math.min(...tokenLatencies);
                const tokenMax = Math.max(...tokenLatencies);

                console.log(`🪙 TOKEN PAYMENTS (Polling - 5s intervals):`);
                console.log(`   Detected: ${tokenPayments.length}/${numPayments}`);
                console.log(`   Average latency: ${tokenAvg.toFixed(0)}ms`);
                console.log(`   Min latency: ${tokenMin}ms`);
                console.log(`   Max latency: ${tokenMax}ms\n`);
              }

              console.log(`${"=".repeat(70)}\n`);

              // Detailed results
              console.log(`📋 Detailed Results:\n`);
              for (const payment of detectionTimes) {
                if (payment.latency) {
                  const method = payment.detectionMethod === 'polling' ? '📊 POLLING' : '📡 EVENT';
                  const icon = payment.type === 'sats' ? '⚡' : '🪙';
                  console.log(`${icon} ${payment.type.toUpperCase()} #${payment.paymentNum}: ${payment.latency}ms (${method})`);
                } else {
                  console.log(`❌ ${payment.type.toUpperCase()} #${payment.paymentNum}: NOT DETECTED`);
                }
              }

              console.log(`\n✅ Benchmark complete!`);

            } catch (error) {
              console.error("❌ Benchmark failed:", error.message);
              process.exit(1);
            }
          }

          benchmarkPayments();
          EOFSCRIPT

          node benchmark-payments.js